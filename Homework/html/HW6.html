
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>HW6</title><meta name="generator" content="MATLAB 9.14"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2024-04-25"><meta name="DC.source" content="HW6.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; }

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }
span.typesection { color:#A0522D }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h2>Contents</h2><div><ul><li><a href="#1">Problem1 (a)</a></li><li><a href="#2">Problem1 (b)</a></li><li><a href="#3">Problem2 (a)</a></li><li><a href="#4">Problem2 (b)</a></li><li><a href="#5">Problem3 Drawing</a></li><li><a href="#6">Problem3 (b)</a></li><li><a href="#7">Problem 4</a></li><li><a href="#8">Problem1 PD Control</a></li><li><a href="#9">Problem2 PD + Feedforward Control</a></li><li><a href="#10">Problem3 Inverse Dynamics Control</a></li></ul></div><h2 id="1">Problem1 (a)</h2><pre class="codeinput"><span class="comment">% Initial conditions</span>
x0 = [0.05; 0; 0.05; 0];

<span class="comment">% Simulate the system using ode45 with PD control</span>
[T, X] = ode45(@(t, x) EoM(t, x, @PD), [0, 2], x0);

<span class="comment">% Plot joint responses</span>
figure(1)
plot(T, X(:, 1), T, X(:, 3), LineWidth = 1)
legend(<span class="string">'q1(t)'</span>, <span class="string">'q2(t)'</span>)
title(<span class="string">'Joint Responses with PD-Control'</span>)
ylabel(<span class="string">'Joint States'</span>)
xlabel(<span class="string">'Time [s]'</span>)
grid <span class="string">on</span>
grid <span class="string">minor</span>

<span class="comment">% Calculate torques and tracking errors</span>
tau = zeros(2, length(T));
e = zeros(2, length(T));
<span class="keyword">for</span> i = 1:length(T)
    [tau(:, i), e(:, i)] = PD(T(i), X(i, :));
<span class="keyword">end</span>

<span class="comment">% Plot tracking errors</span>
figure(2)
plot(T, e(1, :), T, e(2, :), LineWidth = 1)
legend(<span class="string">'e1(t)'</span>, <span class="string">'e2(t)'</span>)
title(<span class="string">'Tracking Errors with PD-Control'</span>)
xlabel(<span class="string">'Time [s]'</span>)
ylabel(<span class="string">'Error'</span>)
grid <span class="string">on</span>
grid <span class="string">minor</span>

<span class="comment">% Plot joint torques</span>
figure(3)
plot(T, tau(1, :), T, tau(2, :), LineWidth = 1)
legend(<span class="string">'u1(t)'</span>, <span class="string">'u2(t)'</span>)
title(<span class="string">'Joint Torques with PD-Control'</span>)
xlabel(<span class="string">'Time [s]'</span>)
ylabel(<span class="string">'Torque'</span>)
grid <span class="string">on</span>
grid <span class="string">minor</span>
</pre><img vspace="5" hspace="5" src="HW6_01.png" alt=""> <img vspace="5" hspace="5" src="HW6_02.png" alt=""> <img vspace="5" hspace="5" src="HW6_03.png" alt=""> <h2 id="2">Problem1 (b)</h2><pre class="codeinput"><span class="comment">% error1(t=1) = 0.0051; Actual e(1) is around 1.5 on the plot</span>
<span class="comment">% error2(t=1) = -0.0101;</span>
<span class="comment">% error1(t=2) = -0.0134;</span>
<span class="comment">% error2(t=2) = 0.0080.</span>

<span class="comment">% Torque1 saturates in the intervals [0, 0.360), (0.41, 0.71], [1, 1.37], and [1.42, 1.75]</span>
<span class="comment">% Torque2 almost does not saturate. It does for around 0.03s at the beginning and near 1s</span>

<span class="comment">% Large tracking errors might be due to the initialization of the system, where the joint angles and velocities are not desired ones.</span>
<span class="comment">% Large initial torques might be due to the high control gain trying to eliminate the tracking error rapidly.</span>
</pre><h2 id="3">Problem2 (a)</h2><pre class="codeinput"><span class="comment">% Generate cubic polynomial reference trajectories</span>
t = 0:0.01:2;
qd = zeros(2, length(t));
vd = zeros(2, length(t));
ad = zeros(2, length(t));
<span class="keyword">for</span> i = 1:length(t)
    [qd(:, i), vd(:, i), ad(:, i)] = cubicpoly(t(i));
<span class="keyword">end</span>

<span class="comment">% Initial conditions</span>
x0 = [0.05; 0; 0.05; 0];

<span class="comment">% Simulate the system using ode45 with PD + Feedforward control</span>
[T, X] = ode45(@(t, x) EoM(t, x, @PD_FeedForward), [0, 2], x0);

<span class="comment">% Plot joint responses</span>
figure(1)
plot(T, X(:, 1), T, X(:, 3), LineWidth=1)
legend(<span class="string">'q1(t)'</span>, <span class="string">'q2(t)'</span>)
title(<span class="string">'Joint Responses with PD &amp; Feedforward-Control'</span>)
ylabel(<span class="string">'Joint States'</span>)
xlabel(<span class="string">'Time [s]'</span>)
grid <span class="string">on</span>
grid <span class="string">minor</span>

<span class="comment">% Calculate torques and tracking errors</span>
tau = zeros(2, length(T));
e = zeros(2, length(T));
<span class="keyword">for</span> i = 1:length(T)
    [tau(:, i), e(:, i)] = PD_FeedForward(T(i), X(i, :));
<span class="keyword">end</span>

<span class="comment">% Plot joint torques</span>
figure(2)
plot(T, tau(1, :), T, tau(2, :), LineWidth=1)
legend(<span class="string">'u1(t)'</span>, <span class="string">'u2(t)'</span>)
title(<span class="string">'Joint Torques with PD + Feedforward-Control'</span>)
xlabel(<span class="string">'Time [s]'</span>)
ylabel(<span class="string">'Torque'</span>)
grid <span class="string">on</span>
grid <span class="string">minor</span>

<span class="comment">% Plot tracking errors</span>
figure(3)
plot(T, e(1, :), T, e(2, :), LineWidth=1)
legend(<span class="string">'e1(t)'</span>, <span class="string">'e2(t)'</span>)
title(<span class="string">'Tracking Errors with PD + Feedforward-Control'</span>)
xlabel(<span class="string">'Time [s]'</span>)
ylabel(<span class="string">'Error'</span>)
grid <span class="string">on</span>
grid <span class="string">minor</span>
</pre><img vspace="5" hspace="5" src="HW6_05.png" alt=""> <img vspace="5" hspace="5" src="HW6_06.png" alt=""> <img vspace="5" hspace="5" src="HW6_07.png" alt=""> <h2 id="4">Problem2 (b)</h2><p>error1(t=1) = -0.0048; error2(t=1) = -0.0523; error1(t=2) = 0.0029; error2(t=2) = -0.0361.</p><pre class="codeinput"><span class="comment">% The errors and input torques are much smaller than those of pure PD</span>
<span class="comment">% control. Joint responses and part of the torque inputs get smoother with</span>
<span class="comment">% the feedforward added on.</span>
</pre><h2 id="5">Problem3 Drawing</h2><pre class="codeinput">clear; clc; close <span class="string">all</span>

<span class="comment">% Initial conditions</span>
x0 = [0.0; 0; 0.0; 0];

<span class="comment">% Simulate the system using ode45 with Inverse Dynamics control</span>
[T, X] = ode45(@(t, x) EoM(t, x, @InvDynamics), [0, 2], x0);

<span class="comment">% Plot joint responses</span>
figure(1)
plot(T, X(:, 1), T, X(:, 3), LineWidth=1)
legend(<span class="string">'q1(t)'</span>, <span class="string">'q2(t)'</span>)
title(<span class="string">'Joint Responses with Inverse Dynamics Control'</span>)
xlabel(<span class="string">'Time [s]'</span>)
grid <span class="string">on</span>
grid <span class="string">minor</span>

<span class="comment">% Calculate torques and tracking errors</span>
tau = zeros(2, length(T));
e = zeros(2, length(T));
<span class="keyword">for</span> i = 1:length(T)
    [tau(:, i), e(:, i)] = InvDynamics(T(i), X(i, :));
<span class="keyword">end</span>

<span class="comment">% Plot joint torques</span>
figure(2)
plot(T, tau(1, :), T, tau(2, :), LineWidth=1)
legend(<span class="string">'u1(t)'</span>, <span class="string">'u2(t)'</span>)
title(<span class="string">'Joint Torques with Inverse Dynamics Control'</span>)
xlabel(<span class="string">'Time [s]'</span>)
ylabel(<span class="string">'Torque'</span>)
grid <span class="string">on</span>
grid <span class="string">minor</span>

<span class="comment">% Plot tracking errors</span>
figure(3)
plot(T, e(1, :), T, e(2, :), LineWidth=1)
legend(<span class="string">'e1(t)'</span>, <span class="string">'e2(t)'</span>)
title(<span class="string">'Tracking Errors with Inverse Dynamics Control'</span>)
xlabel(<span class="string">'Time [s]'</span>)
ylabel(<span class="string">'Error'</span>)
grid <span class="string">on</span>
grid <span class="string">minor</span>
</pre><h2 id="6">Problem3 (b)</h2><pre class="codeinput"><span class="comment">% error1(t=1) = -0.0048;</span>
<span class="comment">% error2(t=1) = -0.0523;</span>
<span class="comment">% error1(t=2) = 0.0029;</span>
<span class="comment">% error2(t=2) = -0.0361.</span>

<span class="comment">% Appreantly the figures are not what they supposed to be. But</span>
<span class="comment">% theoretically, with Inverse Dynamics Control, the errors and the torques should be similar</span>
<span class="comment">% to thoses in PD + FeedForward ones.</span>
</pre><h2 id="7">Problem 4</h2><pre class="codeinput"><span class="comment">% PD controller achieves good tracking with some initial errors presented.</span>
<span class="comment">% PD + FeedForward Controller improves by reducing initial errors with</span>
<span class="comment">% added feedforward terms, but may still exhibit slight overshoot. Inverse</span>
<span class="comment">% Dynamics Control, somehow accurate, but requires very precious dynamics</span>
<span class="comment">% parameters.</span>
</pre><h2 id="8">Problem1 PD Control</h2><pre class="codeinput"><span class="keyword">function</span> dx_dt = EoM(t, x, controller)

    <span class="comment">% Given Dynamic Parameters</span>
    m1 = 7.848; m2 = 4.49;
    l1 = 0.3; lc1 = 0.1554; lc2 = 0.0341;
    I1 = 0.176; I2 = 0.0411;

    <span class="comment">% Retrive qi from State State Representation [X]</span>
    q1 = x(1); q1dot = x(2);
    q2 = x(3); q2dot = x(4);

    <span class="comment">% Inertia matrix D(q)</span>
    D = zeros(2, 2);
    D(1, 1) = m1 * lc1^2 + m2 * (l1^2 + lc2^2 + 2 * l1 * lc2 * cos(q2)) + I1 + I2;
    D(1, 2) = m2 * (lc2^2 + l1 * lc2 * cos(q2)) + I2;
    D(2, 1) = D(1, 2);
    D(2, 2) = m2 * lc2^2 + I2;

    <span class="comment">% Compute Christoffel symbols</span>
    C121 = -m2 * l1 * lc2 * sin(q2);
    C211 = C121;
    C221 = C121;
    C112 = -C121;

    <span class="comment">% Compute control inputs (torques) using the provided controller function</span>
    [tau, ~] = controller(t, x);

    <span class="comment">% Compute accelerations</span>
    a1 = tau(1) - C121 * q1dot * q2dot - C211 * q2dot * q1dot - C221 * q2dot^2;
    a2 = tau(2) - C112 * q1dot^2;

    <span class="comment">% Compute state derivatives</span>
    dx_dt = [x(2); 1 / (D(1, 1) * D(2, 2) - D(2, 1) * D(1, 2)) * (D(2, 2) * a1 - D(1, 2) * a2);
            x(4); 1 / (D(1, 1) * D(2, 2) - D(2, 1) * D(1, 2)) * (-D(2, 1) * a1 + D(1, 1) * a2)];
<span class="keyword">end</span>

<span class="comment">% Function generates cubic polynomial reference trajectories</span>
<span class="comment">% [qd (positions), vd (velocities), ad (accelerations)]</span>
<span class="keyword">function</span> [qd, vd, ad] = cubicpoly(t)
    <span class="keyword">if</span> t &lt;= 1 &amp;&amp; t &gt;= 0
        a = [1 0 0 0;
             0 1 0 0;
             1 1 1 1;
             0 1 2 3] \ [0; 0; pi/2; 0];
    <span class="keyword">elseif</span> t &gt; 1
        a = [1 1 1 1;
             0 1 2 3;
             1 2 4 8;
             0 1 4 1] \ [pi/2; 0; 0; 0];
    <span class="keyword">end</span>

    qd = [a' * [1; t; t.^2; t.^3];
          a' * [1; t; t.^2; t.^3]];

    vd = [a' * [0; 1; 2*t; 3*t.^2];
          a' * [0; 1; 2*t; 3*t.^2]];

    ad = [a' * [0; 0; 2; 6*t];
          a' * [0; 0; 2; 6*t]];
<span class="keyword">end</span>


<span class="keyword">function</span> [tau, e] = PD(t, x)
    <span class="comment">% Extract states</span>
    q1 = x(1); q1dot = x(2);
    q2 = x(3); q2dot = x(4);

    <span class="comment">% Define gains</span>
    kp1 = 100; kp2 = 100;
    kd1 = 20; kd2 = 20;

    <span class="comment">% Calculate desired positions based on time</span>
    <span class="keyword">if</span> t &lt;= 1 &amp;&amp; t &gt;= 0
        q1d = pi/2;
        q2d = pi/2;
    <span class="keyword">elseif</span> t &gt; 1
        q1d = 0;
        q2d = 0;
    <span class="keyword">end</span>

    <span class="comment">% Compute control inputs (torques)</span>
    tau1 = min(max(-10, kp1 * (q1d - q1) - kd1 * q1dot), 10);
    tau2 = min(max(-10, kp2 * (q2d - q2) - kd2 * q2dot), 10);

    tau = [tau1; tau2];

    <span class="comment">% Calculate tracking errors</span>
    e = [q1 - q1d;
         q2 - q2d];
<span class="keyword">end</span>
</pre><img vspace="5" hspace="5" src="HW6_04.png" alt=""> <h2 id="9">Problem2 PD + Feedforward Control</h2><pre class="codeinput"><span class="keyword">function</span> [tau, e] = PD_FeedForward(t, x)
    <span class="comment">% Extract states</span>
    q1 = x(1); q1dot = x(2);
    q2 = x(3); q2dot = x(4);

    <span class="comment">% Define gains</span>
    kp1 = 100; kp2 = 100;
    kd1 = 20; kd2 = 20;

    <span class="comment">% Compute desired positions, velocities, and accelerations using cubic polynomial function</span>
    [qd, vd, ad] = cubicpoly(t);

    <span class="comment">% Compute control inputs (torques) with feedforward</span>
    tau1 = min(max(-10, ad(1) + kp1 * (qd(1) - q1) + kd1 * (vd(1) - q1dot)), 10);
    tau2 = min(max(-10, ad(2) + kp2 * (qd(2) - q2) + kd2 * (vd(2) - q2dot)), 10);

    tau = [tau1; tau2];

    <span class="comment">% Calculate tracking errors</span>
    e = [q1 - qd(1);
         q2 - qd(2)];
<span class="keyword">end</span>
</pre><h2 id="10">Problem3 Inverse Dynamics Control</h2><pre class="codeinput"><span class="keyword">function</span> [tau, e] = InvDynamics(t, x)
    <span class="comment">% Extract states</span>
    q1 = x(1); q1dot = x(2);
    q2 = x(3); q2dot = x(4);

    <span class="comment">% Define gains</span>
    kp1 = 100; kp2 = 100;
    kd1 = 20; kd2 = 20;

    <span class="comment">% Define parameters</span>
    m1 = 7.848; m2 = 4.49;
    l1 = 0.3; lc1 = 0.1554; lc2 = 0.0341;
    I1 = 0.176; I2 = 0.0411;

    <span class="comment">% Compute inertia matrix D</span>
    D = zeros(2, 2);
    D(1, 1) = m1 * lc1^2 + m2 * (l1^2 + lc2^2 + 2 * l1 * lc2 * cos(q2)) + I1 + I2;
    D(1, 2) = m2 * (lc2^2 + l1 * lc2 * cos(q2)) + I2;
    D(2, 1) = D(1, 2);
    D(2, 2) = m2 * lc2^2 + I2;

    <span class="comment">% Compute Christoffel symbols</span>
    C121 = -m2 * l1 * lc2 * sin(q2);
    C211 = C121;
    C221 = C121;
    C112 = -C121;

    <span class="comment">% Compute desired positions, velocities, and accelerations using cubic polynomial function</span>
    [qd, vd, ad] = cubicpoly(t);

    <span class="comment">% Compute desired accelerations with PD control</span>
    aq = ad + [kp1; kp2] * (qd(1) - q1) + [kd1; kd2] * (vd(1) - q1dot);

    <span class="comment">% Compute torques (control inputs) using inverse dynamics</span>
    tau = D * aq + [C121 * q1dot * q2dot + C211 * q2dot * q1dot + C221 * q2dot^2;
                    C112 * q1dot^2];

    <span class="comment">% Ensure torque limits are respected</span>
    tau = [min(max(-10, tau(1)), 10);
           min(max(-10, tau(2)), 10)];

    <span class="comment">% Calculate tracking errors</span>
    e = [q1 - qd(1);
         q2 - qd(2)];
<span class="keyword">end</span>
</pre><img vspace="5" hspace="5" src="HW6_08.png" alt=""> <img vspace="5" hspace="5" src="HW6_09.png" alt=""> <img vspace="5" hspace="5" src="HW6_10.png" alt=""> <p class="footer"><br><a href="https://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2023a</a><br></p></div><!--
##### SOURCE BEGIN #####
%% Problem1 (a)

% Initial conditions
x0 = [0.05; 0; 0.05; 0];

% Simulate the system using ode45 with PD control
[T, X] = ode45(@(t, x) EoM(t, x, @PD), [0, 2], x0);

% Plot joint responses
figure(1)
plot(T, X(:, 1), T, X(:, 3), LineWidth = 1)
legend('q1(t)', 'q2(t)')
title('Joint Responses with PD-Control')
ylabel('Joint States')
xlabel('Time [s]')
grid on
grid minor

% Calculate torques and tracking errors
tau = zeros(2, length(T));
e = zeros(2, length(T));
for i = 1:length(T)
    [tau(:, i), e(:, i)] = PD(T(i), X(i, :));
end

% Plot tracking errors
figure(2)
plot(T, e(1, :), T, e(2, :), LineWidth = 1)
legend('e1(t)', 'e2(t)')
title('Tracking Errors with PD-Control')
xlabel('Time [s]')
ylabel('Error')
grid on
grid minor

% Plot joint torques
figure(3)
plot(T, tau(1, :), T, tau(2, :), LineWidth = 1)
legend('u1(t)', 'u2(t)')
title('Joint Torques with PD-Control')
xlabel('Time [s]')
ylabel('Torque')
grid on
grid minor


%% Problem1 (b)

% error1(t=1) = 0.0051; Actual e(1) is around 1.5 on the plot
% error2(t=1) = -0.0101;
% error1(t=2) = -0.0134;
% error2(t=2) = 0.0080.

% Torque1 saturates in the intervals [0, 0.360), (0.41, 0.71], [1, 1.37], and [1.42, 1.75]
% Torque2 almost does not saturate. It does for around 0.03s at the beginning and near 1s

% Large tracking errors might be due to the initialization of the system, where the joint angles and velocities are not desired ones.
% Large initial torques might be due to the high control gain trying to eliminate the tracking error rapidly.

%% Problem2 (a)

% Generate cubic polynomial reference trajectories
t = 0:0.01:2;
qd = zeros(2, length(t));
vd = zeros(2, length(t));
ad = zeros(2, length(t));
for i = 1:length(t)
    [qd(:, i), vd(:, i), ad(:, i)] = cubicpoly(t(i));
end

% Initial conditions
x0 = [0.05; 0; 0.05; 0];

% Simulate the system using ode45 with PD + Feedforward control
[T, X] = ode45(@(t, x) EoM(t, x, @PD_FeedForward), [0, 2], x0);

% Plot joint responses
figure(1)
plot(T, X(:, 1), T, X(:, 3), LineWidth=1)
legend('q1(t)', 'q2(t)')
title('Joint Responses with PD & Feedforward-Control')
ylabel('Joint States')
xlabel('Time [s]')
grid on
grid minor

% Calculate torques and tracking errors
tau = zeros(2, length(T));
e = zeros(2, length(T));
for i = 1:length(T)
    [tau(:, i), e(:, i)] = PD_FeedForward(T(i), X(i, :));
end

% Plot joint torques
figure(2)
plot(T, tau(1, :), T, tau(2, :), LineWidth=1)
legend('u1(t)', 'u2(t)')
title('Joint Torques with PD + Feedforward-Control')
xlabel('Time [s]')
ylabel('Torque')
grid on
grid minor

% Plot tracking errors
figure(3)
plot(T, e(1, :), T, e(2, :), LineWidth=1)
legend('e1(t)', 'e2(t)')
title('Tracking Errors with PD + Feedforward-Control')
xlabel('Time [s]')
ylabel('Error')
grid on
grid minor

%% Problem2 (b)
% error1(t=1) = -0.0048;
% error2(t=1) = -0.0523;
% error1(t=2) = 0.0029;
% error2(t=2) = -0.0361.

% The errors and input torques are much smaller than those of pure PD
% control. Joint responses and part of the torque inputs get smoother with
% the feedforward added on.

%% Problem3 Drawing

clear; clc; close all

% Initial conditions
x0 = [0.0; 0; 0.0; 0];

% Simulate the system using ode45 with Inverse Dynamics control
[T, X] = ode45(@(t, x) EoM(t, x, @InvDynamics), [0, 2], x0);

% Plot joint responses
figure(1)
plot(T, X(:, 1), T, X(:, 3), LineWidth=1)
legend('q1(t)', 'q2(t)')
title('Joint Responses with Inverse Dynamics Control')
xlabel('Time [s]')
grid on
grid minor

% Calculate torques and tracking errors
tau = zeros(2, length(T));
e = zeros(2, length(T));
for i = 1:length(T)
    [tau(:, i), e(:, i)] = InvDynamics(T(i), X(i, :));
end

% Plot joint torques
figure(2)
plot(T, tau(1, :), T, tau(2, :), LineWidth=1)
legend('u1(t)', 'u2(t)')
title('Joint Torques with Inverse Dynamics Control')
xlabel('Time [s]')
ylabel('Torque')
grid on
grid minor

% Plot tracking errors
figure(3)
plot(T, e(1, :), T, e(2, :), LineWidth=1)
legend('e1(t)', 'e2(t)')
title('Tracking Errors with Inverse Dynamics Control')
xlabel('Time [s]')
ylabel('Error')
grid on
grid minor

%% Problem3 (b)

% error1(t=1) = -0.0048;
% error2(t=1) = -0.0523;
% error1(t=2) = 0.0029;
% error2(t=2) = -0.0361.

% Appreantly the figures are not what they supposed to be. But
% theoretically, with Inverse Dynamics Control, the errors and the torques should be similar
% to thoses in PD + FeedForward ones.

%% Problem 4

% PD controller achieves good tracking with some initial errors presented.
% PD + FeedForward Controller improves by reducing initial errors with
% added feedforward terms, but may still exhibit slight overshoot. Inverse
% Dynamics Control, somehow accurate, but requires very precious dynamics
% parameters.


%% Problem1 PD Control

function dx_dt = EoM(t, x, controller)

    % Given Dynamic Parameters
    m1 = 7.848; m2 = 4.49;
    l1 = 0.3; lc1 = 0.1554; lc2 = 0.0341;
    I1 = 0.176; I2 = 0.0411;

    % Retrive qi from State State Representation [X]
    q1 = x(1); q1dot = x(2);
    q2 = x(3); q2dot = x(4);
    
    % Inertia matrix D(q)
    D = zeros(2, 2);
    D(1, 1) = m1 * lc1^2 + m2 * (l1^2 + lc2^2 + 2 * l1 * lc2 * cos(q2)) + I1 + I2;
    D(1, 2) = m2 * (lc2^2 + l1 * lc2 * cos(q2)) + I2;
    D(2, 1) = D(1, 2);
    D(2, 2) = m2 * lc2^2 + I2;
    
    % Compute Christoffel symbols
    C121 = -m2 * l1 * lc2 * sin(q2);
    C211 = C121;
    C221 = C121;
    C112 = -C121;
    
    % Compute control inputs (torques) using the provided controller function
    [tau, ~] = controller(t, x);
    
    % Compute accelerations
    a1 = tau(1) - C121 * q1dot * q2dot - C211 * q2dot * q1dot - C221 * q2dot^2;
    a2 = tau(2) - C112 * q1dot^2;
    
    % Compute state derivatives
    dx_dt = [x(2); 1 / (D(1, 1) * D(2, 2) - D(2, 1) * D(1, 2)) * (D(2, 2) * a1 - D(1, 2) * a2);
            x(4); 1 / (D(1, 1) * D(2, 2) - D(2, 1) * D(1, 2)) * (-D(2, 1) * a1 + D(1, 1) * a2)];
end

% Function generates cubic polynomial reference trajectories
% [qd (positions), vd (velocities), ad (accelerations)]
function [qd, vd, ad] = cubicpoly(t)
    if t <= 1 && t >= 0
        a = [1 0 0 0;
             0 1 0 0;
             1 1 1 1;
             0 1 2 3] \ [0; 0; pi/2; 0];
    elseif t > 1
        a = [1 1 1 1;
             0 1 2 3;
             1 2 4 8;
             0 1 4 1] \ [pi/2; 0; 0; 0];
    end
    
    qd = [a' * [1; t; t.^2; t.^3];
          a' * [1; t; t.^2; t.^3]];
      
    vd = [a' * [0; 1; 2*t; 3*t.^2];
          a' * [0; 1; 2*t; 3*t.^2]];
      
    ad = [a' * [0; 0; 2; 6*t];
          a' * [0; 0; 2; 6*t]];
end


function [tau, e] = PD(t, x)
    % Extract states
    q1 = x(1); q1dot = x(2);
    q2 = x(3); q2dot = x(4);
    
    % Define gains
    kp1 = 100; kp2 = 100;
    kd1 = 20; kd2 = 20;
    
    % Calculate desired positions based on time
    if t <= 1 && t >= 0
        q1d = pi/2;
        q2d = pi/2;
    elseif t > 1
        q1d = 0;
        q2d = 0;
    end
    
    % Compute control inputs (torques)
    tau1 = min(max(-10, kp1 * (q1d - q1) - kd1 * q1dot), 10);
    tau2 = min(max(-10, kp2 * (q2d - q2) - kd2 * q2dot), 10);
    
    tau = [tau1; tau2];
    
    % Calculate tracking errors
    e = [q1 - q1d;
         q2 - q2d];
end




%% Problem2 PD + Feedforward Control

function [tau, e] = PD_FeedForward(t, x)
    % Extract states
    q1 = x(1); q1dot = x(2);
    q2 = x(3); q2dot = x(4);
    
    % Define gains
    kp1 = 100; kp2 = 100;
    kd1 = 20; kd2 = 20;
    
    % Compute desired positions, velocities, and accelerations using cubic polynomial function
    [qd, vd, ad] = cubicpoly(t);
    
    % Compute control inputs (torques) with feedforward
    tau1 = min(max(-10, ad(1) + kp1 * (qd(1) - q1) + kd1 * (vd(1) - q1dot)), 10);
    tau2 = min(max(-10, ad(2) + kp2 * (qd(2) - q2) + kd2 * (vd(2) - q2dot)), 10);
    
    tau = [tau1; tau2];
    
    % Calculate tracking errors
    e = [q1 - qd(1);
         q2 - qd(2)];
end


%% Problem3 Inverse Dynamics Control

function [tau, e] = InvDynamics(t, x)
    % Extract states
    q1 = x(1); q1dot = x(2);
    q2 = x(3); q2dot = x(4);
    
    % Define gains
    kp1 = 100; kp2 = 100;
    kd1 = 20; kd2 = 20;
    
    % Define parameters
    m1 = 7.848; m2 = 4.49;
    l1 = 0.3; lc1 = 0.1554; lc2 = 0.0341;
    I1 = 0.176; I2 = 0.0411;
    
    % Compute inertia matrix D
    D = zeros(2, 2);
    D(1, 1) = m1 * lc1^2 + m2 * (l1^2 + lc2^2 + 2 * l1 * lc2 * cos(q2)) + I1 + I2;
    D(1, 2) = m2 * (lc2^2 + l1 * lc2 * cos(q2)) + I2;
    D(2, 1) = D(1, 2);
    D(2, 2) = m2 * lc2^2 + I2;
    
    % Compute Christoffel symbols
    C121 = -m2 * l1 * lc2 * sin(q2);
    C211 = C121;
    C221 = C121;
    C112 = -C121;
    
    % Compute desired positions, velocities, and accelerations using cubic polynomial function
    [qd, vd, ad] = cubicpoly(t);
    
    % Compute desired accelerations with PD control
    aq = ad + [kp1; kp2] * (qd(1) - q1) + [kd1; kd2] * (vd(1) - q1dot);
    
    % Compute torques (control inputs) using inverse dynamics
    tau = D * aq + [C121 * q1dot * q2dot + C211 * q2dot * q1dot + C221 * q2dot^2;
                    C112 * q1dot^2];
                
    % Ensure torque limits are respected
    tau = [min(max(-10, tau(1)), 10);
           min(max(-10, tau(2)), 10)];
    
    % Calculate tracking errors
    e = [q1 - qd(1);
         q2 - qd(2)];
end













##### SOURCE END #####
--></body></html>